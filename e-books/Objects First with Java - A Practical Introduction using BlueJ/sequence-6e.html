<html><!-- InstanceBegin template="/Templates/objects-first.dwt" codeOutsideHTMLIsLocked="false" -->

<head>
<!-- #BeginEditable "doctitle" --> 
<TITLE>Objects First With Java - A Practical Introduction Using BlueJ</TITLE>
<!-- #EndEditable -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="style.css" rel="stylesheet" type="text/css">
<!-- InstanceParam name="side bar" type="boolean" value="true" -->
</head>



<body background="images/decor/of-6e-bg.png">
<br>
<table width="800" border="0" align="center" cellpadding="10" cellspacing="0" bordercolor="#000000" bgcolor="#FFFFFF" class="border">
  <tr> 
    <td valign="top"><!-- #BeginEditable "body" --> 
            <table width="500" border="0" align="center" cellpadding="5">
              <tr>
                <td>
                  <p><b><font size="+1">Objects First with Java<br>
                    A Practical Introduction using BlueJ</font></b></p>
                  <p><b>Chapter sequence</b><font face="Georgia, Times New Roman, Times, serif"> 
                    </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter 
                    1</strong> deals with the most fundamental concepts of object-orientation: 
                    objects, classes and methods. It gives a solid, hands-on introduction 
                    to these concepts without going into the details of Java syntax. 
                    It also gives a first look at some source code. We do this 
                    by using an example of graphical shapes which can be interactively 
                    drawn, and a second example of a simple laboratory class enrolment 
                    system. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter 
                    2</strong> opens up class definitions and investigates how 
                    Java source code is written to create behavior of objects. 
                    We discuss how to define fields and implement methods. Here, 
                    we also introduce the first types of statements. The main 
                    example is an implementation of a ticket machine. We also 
                    look back to the laboratory class example from chapter 1 to 
                    investigate that a bit further. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter 
                    3</strong> then enlarges the picture to discuss interaction 
                    of multiple objects. We see how objects can collaborate by 
                    invoking each other’s methods to perform a common task. We 
                    also discuss how one object can create other objects. A digital 
                    alarm clock display is discussed that uses two number display 
                    objects to show hours and minutes. As a second major example, 
                    we examine a simulation of an email system in which messages 
                    can be sent between mail clients. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif">In <strong>Chapter 
                    4</strong>, we continue by building more extensive structures 
                    of objects. Most importantly, we start using collections of 
                    objects. We implement a music player and an auction 
                    system to introduce collections. At the same time, we discuss 
                    iterations over collection and have a first look at loops. 
                    The first collection being used is an ArrayList. In the second 
                    half of the chapter we introduce arrays as a special form 
                    of a collection, and the for loop as another form of a loop. 
                    We discuss an implementation of a web log analyzer as an example 
                    for array use. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter 
                    5</strong> is labbelled as an &quot;advanced&quot; chapter. This means that the material can be studied here, or it can initially be skipped if the reader wants to move forward more quickly. The material in this chapter introduces concepts of functional programming, such as lambdas and streams, and revisits the processing of collections&ndash;just covered in the previous chapter&ndash;in this alternative style.</font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter 
                    6</strong> deals with libraries and interfaces. We introduce 
                    the Java standard library and discuss some important library 
                    classes. More importantly, we explain how to read and understand 
                    the library documentation. The importance of writing documentation 
                    in software development projects is discussed, and we end 
                    by practicing how to write suitable documentation for our 
                    own classes. Random, Set and Map are examples of classes that 
                    we encounter in this chapter. We implement an <em>Eliza</em>-like dialogue 
                    system and a graphical simulation of a bouncing ball to apply 
                    these classes. </font>                  </p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter 
                    7</strong> goes back to collections, this time covering fixed-size collection, i.e. arrays. We discuss the traditional for loop as the most appropriate loop structure, and other array specifics.</font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif">In <strong>Chapter 
                    8</strong>, we discuss more formally the issues of dividing 
                    a problem domain into classes for implementation. We introduce 
                    issues of designing classes well, including concepts such 
                    as responsibility-driven design, coupling, cohesion, and refactoring. 
                    An interactive, text-based, adventure game (<em>World of
                    Zuul</em>) 
                    is used for this discussion. We go through several iterations 
                    of improving the internal class structure of the game and 
                    extending its functionality, and end with a long list of proposals 
                    for extensions that may be done as student projects. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter
                         9</strong>, titled <em>Well-behaved objects</em>, deals
                         with a whole  group of issues connected to producing
                         correct, understandable,  and maintainable classes.
                         It covers issues ranging from writing  clear, understandable
                         code - including style and commenting 
                    - to testing and debugging. Test strategies are introduced
                     and a number of debugging methods are discussed in detail.
                     We use an example of an online shopping site and  an implementation of an electronic calculator to discuss
                    these  topics. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapters 
                    10 and 11</strong> introduce inheritance and polymorphism with 
                    many of the related detailed issues. We discuss a part of the implementation of a social networking site to illustrate the concepts. Issues of code 
                    inheritance, subtyping, polymorphic method calls and overriding 
                    are discussed in detail. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif">In <strong>Chapter 
                    12</strong> we implement a predator/prey simulation. This 
                    serves to discuss additional abstraction mechanisms based 
                    on inheritance, namely interfaces and abstract classes. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter
                        13</strong> introduces two new examples: an image viewer
                        and a sound player. Both examples serve to discuss how
                        to build graphical user interfaces (GUIs).</font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter
                            14</strong> then picks up the difficult issue of
                            how to deal with errors. Several possible problems
                            and solutions are discussed, and Java’s exception
                            handling mechanism is discussed in detail. We extend
                            and improve an address book application to illustrate
                            the concepts. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif"><strong>Chapter
                         15</strong> steps back to discuss in more detail the
                         next  level of abstraction: how to structure a vaguely
                         described  problem into classes and methods. In previous
                         chapters we  have assumed that large parts of the application
                         structure  already exist, and we have made improvements.
                         Now it is time  to discuss how we can get started from
                         a clean slate. This  involves detailed discussion of
                         what the classes should be  that implement our application,
                         how they interact, and how  responsibilities should
                         be distributed. We use class-responsibilities-collaborators
                          (CRC) cards to approach this problem, while designing
                         a cinema  booking system. </font></p>
                  <p><font face="Georgia, Times New Roman, Times, serif">In <strong>Chapter
                         16</strong>, we try to bring everything together and
                         integrate  many topics from the previous chapters of
                         the book. It is  a complete case study, starting with
                         the application design,  through design of the class
                         interfaces, down to discussing  many important functional
                         and non-functional characteristics  and implementation
                         details. Topics discussed in earlier chapters  (such
                         as reliability, data structures, class design, testing,
                          extendibility, etc.) are applied again in a new context. </font></p>
                  <p><a href="description.html">Back to book description</a></p>
                  <p><a href="index.html">Back to main page</a></p></td>
              </tr>
      </table>
      <p>&nbsp;</p>
            <!-- #EndEditable --></td>
  </tr>
</table>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-301920-3";
urchinTracker();
</script>

</body>



<!-- InstanceEnd --></html>



