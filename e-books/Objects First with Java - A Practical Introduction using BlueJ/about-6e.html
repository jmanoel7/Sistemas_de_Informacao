<html><!-- InstanceBegin template="/Templates/objects-first.dwt" codeOutsideHTMLIsLocked="false" -->

<head>
<!-- #BeginEditable "doctitle" --> 
<TITLE>Objects First With Java - A Practical Introduction Using BlueJ</TITLE>
<!-- #EndEditable -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="style.css" rel="stylesheet" type="text/css">
<!-- InstanceParam name="side bar" type="boolean" value="true" -->
</head>



<body background="images/decor/of-6e-bg.png">
<br>
<table width="800" border="0" align="center" cellpadding="10" cellspacing="0" bordercolor="#000000" bgcolor="#FFFFFF" class="border">
  <tr> 
    <td valign="top"><!-- #BeginEditable "body" --> 
            <table width="500" border="0" align="center" cellpadding="5">
              <tr> 
                <td><h2>New to the sixth edition</h2>
                  <p>                  This is the sixth edition of this book, and &ndash; as before with previous new editions &ndash; the content has been adapted to the changed world we now find ourselves in when we develop object-oriented programs.</p>
                  <p>Many of the changes this time can,&nbsp;on the surface, be attributed to a new version of Java: Java 8. This version was released in 2014 and is now very widely used in practice. In fact, it is the fastest adoption of any new Java version ever released; it is time to also change the way we teach novice students.</p>
                  <p>The changes are, however, more than merely the addition of a few new language constructs. The most significant new aspects in Java 8 center around the addition of constructs to support a (partial) functional programming style. And it is this growing recent popularity of and interest in functional programming that is driving this change. The difference is much deeper, and much more fundamental, than just adding new syntax. And it is the renaissance of the functional ideas in general in modern programming, not mainly the existence of Java 8, that make it timely to cover these aspects in a modern edition of a programming textbook.</p>
                  <p>The ideas and techniques of functional programming, while fairly old and well known in principle, have seen a marked boost of popularity in recent years, with new languages being developed, and selected functional techniques being incorporated into existing, traditionally imperative languages. One of the primary reasons for this is the change in computing hardware available, and &ndash; with it &ndash; the changing nature of problems we wish to tackle.</p>
                  <p>Almost all programming platforms now are concurrent. Even mid-range laptops and mobile phones now have processors with multiple cores, making parallel processing a real possibility on everyday devices. Except &ndash; this is not what is happening at a large scale in practice.</p>
                  <p>Writing applications that make optimal use of concurrent processing and multiple processors is very, very difficult. Most applications we can buy today are very far from exploiting the available hardware to a degree approaching anything that would theoretically be possible.</p>
                  <p>This is not going to change much: The opportunity (and challenge) of parallel hardware will remain, and programming these devices with traditional imperative languages will not get any easier.</p>
                  <p>This is where functional programming enters the stage.</p>
                  <p>With functional language constructs, it is possible to automate some concurrency very efficiently. Programs can potentially make use of multiple cores without much effort on the side of the programmer. Functional constructs have other advantages &ndash; more elegant expression for certain problems and better readability in many cases &ndash; but it is the ability to deal with parallelism that will ensure that functional aspects of programming are going to stay with us for a long time to come.</p>
                  <p>Every teacher who wants to prepare their students for the future should now give them some understanding of functional aspects as well. Without it, one will no longer be able to become a master programmer anymore. A novice certainly does not have to master all of functional programming, but a basic understanding of what it is &ndash; and what we can achieve with it &ndash; will soon be considered essential.</p>
                  <p>When exactly functional techniques should be introduced is an interesting question. We do not believe that here is a single right answer for this; various sequences are possible. Functional programming could be covered as an advanced topic at the end of the traditional corpus of this book, or it could be addressed when we first encounter the topics where it is applicable, as an alternative to the imperative techniques. It could even be covered first.</p>
                  <p>An additional question is how to treat the traditional style of programming in those areas where functional constructs are now available: Should they be replaced, or do both need to be covered?</p>
                  <p>For this book, we recognise that different teachers will have different constraints and preferences. Therefore, we have designed a structure that &ndash; we hope &ndash; allows various different approaches, depending on the preference of the learner or teacher.</p>
                <ul>
                  <li>
                    <p>We have not replaced the &ldquo;old-style&rdquo; techniques, but instead cover the new, functional approach in addition to the existing material. Functional constructs in Java are most prominent when working with collections of objects, and the traditional approach &ndash; using loops and explicit iteration &ndash; is still essential to master for any programmer. Not only are there millions of lines of code out there that are written in this style &ndash; and will be continued to be written in this style &ndash; but there are also cases where it is necessary to make use of these techniques even if one generally favors the new, functional constructs. Mastering both is the goal.</p>
                  </li>
                  <li>
                    <p>We present the new, functionally-oriented material at the place in the book where we discuss the problems that are addressed by these constructs. For example, we address functional collection processing as soon as we encounter collections. </p>
                  </li>
                  <li>
                    <p>Chapters and sections covering this new material are, however, clearly marked as &ldquo;Advanced&rdquo;, and are structured in a manner that they can safely be skipped on first reading (or left out altogether).</p>
                  </li>
                  <li>
                    <p>The previous two points enable different approaches to studying this book: If time permits, it can be read in the sequence it is presented, covering the full scope of material &ndash; including functional approaches as alternatives to imperative ones &ndash; as the problems are encountered which they address. If time is short, these advanced sections can be skipped, and emphasis can be placed on a thorough grounding in imperative, object-oriented programming. (We should emphasise that &ldquo;functional&rdquo; is not a contradiction to &ldquo;object-oriented&rdquo;: whether the functional material is included in the study, or whether a reader concentrates on imperative techniques, every reader of this book will emerge with a good understanding of object orientation!) Yet another way to approach the material is to skip the advanced sections initially, and cover them as a separate unit at a later time. They present alternative approaches to other constructs and can be covered independently.</p>
                  </li>
                </ul>
                <p>We hope this makes clear that this book provides flexibility where readers want it, but also guidance where a reader has no clear preference: just read it in the sequence it is written.</p>
                <p>Apart from the major changes described so far, this edition also presents numerous small improvements in many places. The overall structure, tone, and approach of the book is unchanged; it has worked very well in the past, and there is no reason to deviate from it. However, we continuously re-evaluate and seek to improve where we see opportunities. We now have almost 15 years of continuous experience teaching with this book, and this is reflected and many small changes throughout.</p></td>
              </tr>
      </table>
            <p><a href="index.html">Back to main page</a></p>
            <!-- #EndEditable --></td>
  </tr>
</table>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-301920-3";
urchinTracker();
</script>

</body>



<!-- InstanceEnd --></html>



